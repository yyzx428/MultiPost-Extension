/**
 * @file chain-action.tsx
 * @description ÈìæÂºèÊìç‰ΩúÂºπÁ™óÈ°µÈù¢ÁªÑ‰ª∂ - ÈááÁî®ÂèëÂ∏ÉÂºπÁ™óÈ£éÊ†ºÔºåËá™Âä®ÊâßË°å
 */

import '~style.css';
import React, { useEffect, useState, useRef } from 'react';
import {
    HeroUIProvider,
    Button,
    Progress,
    Switch,
    Tooltip,
    NumberInput,
    Chip
} from '@heroui/react';
import {
    RefreshCw,
    X,
    CheckCircle,
    XCircle,
    Clock
} from 'lucide-react';
import { executeChainActionByName, type ChainActionBase, getAvailableChainActions } from '~chain-actions';
import { Storage } from '@plasmohq/storage';
import cssText from 'data-text:~style.css';

const storage = new Storage({ area: 'local' });

//===================================
// Plasmo Ê°ÜÊû∂ÂøÖÈúÄÁöÑÂØºÂá∫ÂáΩÊï∞
//===================================

export function getShadowContainer() {
    return document.querySelector('#test-shadow').shadowRoot.querySelector('#plasmo-shadow-container');
}

export const getShadowHostId = () => 'test-shadow';

export const getStyle = () => {
    const style = document.createElement('style');
    style.textContent = cssText;
    return style;
};

//===================================
// Â∏∏ÈáèÂÆö‰πâ
//===================================

const AUTO_CLOSE_KEY = 'chain-action-auto-close';
const AUTO_CLOSE_DELAY_KEY = 'chain-action-auto-close-delay';
const DEFAULT_AUTO_CLOSE_DELAY = 2 * 60; // 2 minutes in seconds

//===================================
// Á±ªÂûãÂÆö‰πâ
//===================================

interface ChainActionConfig {
    action: string;
    config: Record<string, unknown>;
    traceId?: string;
}

interface StepStatus {
    name: string;
    status: 'waiting' | 'running' | 'success' | 'error';
    message?: string;
    result?: Record<string, unknown>;
    error?: string;
}

interface ChainActionState {
    config: ChainActionConfig | null;
    steps: StepStatus[];
    isExecuting: boolean;
    logs: string[];
    result: Record<string, unknown> | null;
    error: string | null;
}

//===================================
// Â∑•ÂÖ∑ÂáΩÊï∞
//===================================

// ËÅöÁÑ¶Âà∞‰∏ªÁ™óÂè£ÁöÑÂáΩÊï∞
const focusMainWindow = async () => {
    const windows = await chrome.windows.getAll();
    const mainWindow = windows.find((window) => window.type === 'normal');
    if (mainWindow?.id) {
        await chrome.windows.update(mainWindow.id, { focused: true });
    }
};

const getTitleFromConfig = (config: ChainActionConfig | null, availableActions: ChainActionBase[]) => {
    if (!config) return 'ÈìæÂºèÊìç‰Ωú';

    const action = availableActions.find(a => a.name === config.action);
    return action?.name || config.action;
};

//===================================
// ‰∏ªÁªÑ‰ª∂
//===================================

export default function ChainActionModal() {
    const [state, setState] = useState<ChainActionState>({
        config: null,
        steps: [],
        isExecuting: false,
        logs: [],
        result: null,
        error: null
    });

    const [availableActions, setAvailableActions] = useState<ChainActionBase[]>([]);
    const [autoClose, setAutoClose] = useState(true);
    const [countdown, setCountdown] = useState<number>(0);
    const [autoCloseDelay, setAutoCloseDelay] = useState<number>(DEFAULT_AUTO_CLOSE_DELAY);
    const autoCloseTimerRef = useRef<NodeJS.Timeout>();
    const countdownTimerRef = useRef<NodeJS.Timeout>();
    const logsEndRef = useRef<HTMLDivElement>(null);

    //===================================
    // ÂàùÂßãÂåñ
    //===================================

    useEffect(() => {
        // Âä†ËΩΩËá™Âä®ÂÖ≥Èó≠ËÆæÁΩÆ
        loadAutoCloseSettings();

        // Ëé∑ÂèñÂèØÁî®ÁöÑÈìæÂºèÊìç‰Ωú
        loadAvailableActions();

        // ‰ªé background script Ëé∑ÂèñÈÖçÁΩÆÊï∞ÊçÆÂπ∂Ëá™Âä®ÊâßË°å
        requestChainActionData();
    }, []);

    useEffect(() => {
        // Â¶ÇÊûúÊâßË°åÂÆåÊàê‰∏îÂêØÁî®‰∫ÜËá™Âä®ÂÖ≥Èó≠ÔºåÂºÄÂßãÂÄíËÆ°Êó∂
        if (!state.isExecuting && state.result && autoClose) {
            startAutoCloseTimer();
        }

        return () => {
            if (autoCloseTimerRef.current) {
                clearTimeout(autoCloseTimerRef.current);
            }
            if (countdownTimerRef.current) {
                clearInterval(countdownTimerRef.current);
            }
        };
    }, [state.isExecuting, state.result, autoClose]);

    const loadAvailableActions = async () => {
        try {
            const actions = getAvailableChainActions();
            setAvailableActions(actions);
        } catch (error) {
            console.error('Âä†ËΩΩÂèØÁî®ÈìæÂºèÊìç‰ΩúÂ§±Ë¥•:', error);
            addLog('‚ùå Âä†ËΩΩÂèØÁî®ÈìæÂºèÊìç‰ΩúÂ§±Ë¥•: ' + error.message);
        }
    };

    const requestChainActionData = () => {
        chrome.runtime.sendMessage(
            { action: 'MUTLIPOST_EXTENSION_CHAIN_ACTION_REQUEST_DATA' },
            (response) => {
                console.log('Êî∂Âà∞ÈìæÂºèÊìç‰ΩúÈÖçÁΩÆ:', response);
                if (response?.config) {
                    setState(prev => ({
                        ...prev,
                        config: response.config
                    }));
                    initializeSteps(response.config.action);

                    // Ëá™Âä®ÂºÄÂßãÊâßË°åÈìæÂºèÊìç‰Ωú
                    setTimeout(() => {
                        executeChainAction();
                    }, 1000); // Âª∂Ëøü1ÁßíÂºÄÂßãÊâßË°åÔºåËÆ©Áî®Êà∑ÁúãÂà∞ÁïåÈù¢
                } else {
                    addLog('‚ùå Êú™Ëé∑ÂèñÂà∞ÈìæÂºèÊìç‰ΩúÈÖçÁΩÆÊï∞ÊçÆ');
                }
            }
        );
    };

    const loadAutoCloseSettings = async () => {
        const savedAutoClose = await storage.get<boolean>(AUTO_CLOSE_KEY);
        const savedDelay = await storage.get<number>(AUTO_CLOSE_DELAY_KEY);

        if (savedAutoClose !== undefined) {
            setAutoClose(savedAutoClose);
        }
        if (savedDelay !== undefined) {
            setAutoCloseDelay(savedDelay);
        }
    };

    //===================================
    // Ëá™Âä®ÂÖ≥Èó≠Áõ∏ÂÖ≥
    //===================================

    const startAutoCloseTimer = (delaySeconds?: number) => {
        const delay = delaySeconds || autoCloseDelay;

        if (autoCloseTimerRef.current) {
            clearTimeout(autoCloseTimerRef.current);
        }
        if (countdownTimerRef.current) {
            clearInterval(countdownTimerRef.current);
        }

        setCountdown(delay);

        countdownTimerRef.current = setInterval(() => {
            setCountdown((prev) => {
                if (prev <= 1) {
                    clearInterval(countdownTimerRef.current);
                    handleCloseWindow();
                    return 0;
                }
                return prev - 1;
            });
        }, 1000);

        autoCloseTimerRef.current = setTimeout(() => {
            handleCloseWindow();
        }, delay * 1000);
    };

    const handleAutoCloseChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const newAutoClose = event.target.checked;
        setAutoClose(newAutoClose);
        await storage.set(AUTO_CLOSE_KEY, newAutoClose);

        if (!newAutoClose) {
            if (autoCloseTimerRef.current) {
                clearTimeout(autoCloseTimerRef.current);
            }
            if (countdownTimerRef.current) {
                clearInterval(countdownTimerRef.current);
            }
            setCountdown(0);
        } else if (!state.isExecuting && state.result) {
            startAutoCloseTimer();
        }
    };

    const handleDelayChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const newDelay = parseInt(event.target.value) * 60; // ËΩ¨Êç¢‰∏∫Áßí
        setAutoCloseDelay(newDelay);
        await storage.set(AUTO_CLOSE_DELAY_KEY, newDelay);

        if (autoClose && !state.isExecuting && state.result) {
            startAutoCloseTimer(newDelay);
        }
    };

    //===================================
    // Ê≠•È™§ÂàùÂßãÂåñ
    //===================================

    const initializeSteps = (actionName: string) => {
        const steps: StepStatus[] = [];

        switch (actionName) {
            case 'baidu-agiso':
                steps.push(
                    { name: 'ÁôæÂ∫¶‰∫ëÂàÜ‰∫´', status: 'waiting' },
                    { name: 'AgisoÂèëÂ∏É', status: 'waiting' }
                );
                break;
            default:
                steps.push({ name: 'ÊâßË°å‰∏≠', status: 'waiting' });
        }

        setState(prev => ({ ...prev, steps }));
    };

    //===================================
    // Êó•ÂøóÁÆ°ÁêÜ
    //===================================

    const addLog = (message: string) => {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}`;

        setState(prev => ({
            ...prev,
            logs: [...prev.logs, logEntry]
        }));

        // Ëá™Âä®ÊªöÂä®Âà∞Â∫ïÈÉ®
        setTimeout(() => {
            logsEndRef.current?.scrollIntoView({ behavior: 'smooth' });
        }, 100);
    };

    //===================================
    // ÊâßË°åÈìæÂºèÊìç‰Ωú
    //===================================

    const executeChainAction = async () => {
        if (!state.config) {
            addLog('‚ùå ÈÖçÁΩÆÊï∞ÊçÆ‰∏∫Á©∫');
            return;
        }

        setState(prev => ({
            ...prev,
            isExecuting: true,
            error: null,
            logs: []
        }));

        addLog('üöÄ ÂºÄÂßãÊâßË°åÈìæÂºèÊìç‰Ωú: ' + state.config.action);

        try {
            // Êõ¥Êñ∞Ê≠•È™§Áä∂ÊÄÅ
            updateStepStatus(0, 'running', 'Ê≠£Âú®ÊâßË°å...');

            const result = await executeChainActionByName(
                state.config.action,
                state.config.config
            );

            // Êõ¥Êñ∞Ê≠•È™§Áä∂ÊÄÅ
            const resultData = result as { success: boolean; error?: string };
            if (resultData.success) {
                updateStepStatus(0, 'success', 'ÊâßË°åÊàêÂäü');
                if (state.steps.length > 1) {
                    updateStepStatus(1, 'success', 'ÊâßË°åÊàêÂäü');
                }
                addLog('‚úÖ ÈìæÂºèÊìç‰ΩúÊâßË°åÊàêÂäü');
            } else {
                updateStepStatus(0, 'error', resultData.error || 'ÊâßË°åÂ§±Ë¥•');
                addLog('‚ùå ÈìæÂºèÊìç‰ΩúÊâßË°åÂ§±Ë¥•: ' + (resultData.error || 'Êú™Áü•ÈîôËØØ'));
            }

            setState(prev => ({
                ...prev,
                result: result as Record<string, unknown>,
                isExecuting: false
            }));

            // ÊâßË°åÂÆåÊàêÂêéËÅöÁÑ¶Âà∞‰∏ªÁ™óÂè£
            setTimeout(async () => {
                await focusMainWindow();
            }, 1000);

        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            updateStepStatus(0, 'error', errorMessage);
            addLog('‚ùå ÊâßË°åËøáÁ®ã‰∏≠Âá∫Èîô: ' + errorMessage);

            setState(prev => ({
                ...prev,
                error: errorMessage,
                isExecuting: false
            }));
        }
    };

    //===================================
    // Ê≠•È™§Áä∂ÊÄÅÊõ¥Êñ∞
    //===================================

    const updateStepStatus = (stepIndex: number, status: StepStatus['status'], message?: string) => {
        setState(prev => ({
            ...prev,
            steps: prev.steps.map((step, index) =>
                index === stepIndex
                    ? { ...step, status, message }
                    : step
            )
        }));
    };

    //===================================
    // ÈáçËØïÂäüËÉΩ
    //===================================

    const retryExecution = () => {
        setState(prev => ({
            ...prev,
            steps: prev.steps.map(step => ({ ...step, status: 'waiting' })),
            error: null,
            result: null
        }));
        executeChainAction();
    };

    //===================================
    // ÂÖ≥Èó≠ÂºπÁ™ó
    //===================================

    const handleCloseWindow = () => {
        window.close();
    };

    //===================================
    // Ê∏≤ÊüìÂáΩÊï∞
    //===================================

    const renderStepIcon = (status: StepStatus['status']) => {
        switch (status) {
            case 'waiting':
                return <Clock className="w-4 h-4 text-gray-400" />;
            case 'running':
                return <RefreshCw className="w-4 h-4 text-blue-500 animate-spin" />;
            case 'success':
                return <CheckCircle className="w-4 h-4 text-green-500" />;
            case 'error':
                return <XCircle className="w-4 h-4 text-red-500" />;
            default:
                return <Clock className="w-4 h-4 text-gray-400" />;
        }
    };

    const renderStepChip = (status: StepStatus['status']) => {
        const getVariant = (status: StepStatus['status']) => {
            switch (status) {
                case 'waiting': return 'flat';
                case 'running': return 'solid';
                case 'success': return 'solid';
                case 'error': return 'solid';
                default: return 'flat';
            }
        };

        const getColor = (status: StepStatus['status']) => {
            switch (status) {
                case 'waiting': return 'default';
                case 'running': return 'primary';
                case 'success': return 'success';
                case 'error': return 'danger';
                default: return 'default';
            }
        };

        const labels = {
            waiting: 'Á≠âÂæÖ‰∏≠',
            running: 'ÊâßË°å‰∏≠',
            success: 'ÊàêÂäü',
            error: 'Â§±Ë¥•'
        };

        return (
            <Chip variant={getVariant(status)} color={getColor(status)} size="sm">
                {labels[status]}
            </Chip>
        );
    };

    const getNotice = () => {
        if (state.isExecuting) {
            return 'Ê≠£Âú®ÊâßË°åÈìæÂºèÊìç‰Ωú...';
        }
        if (state.error) {
            return 'ÊâßË°åÂ§±Ë¥•';
        }
        if (state.result) {
            return 'ÊâßË°åÂÆåÊàê';
        }
        return 'ÂáÜÂ§áÊâßË°å';
    };

    //===================================
    // ‰∏ªÊ∏≤Êüì
    //===================================

    return (
        <HeroUIProvider>
            <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-background">
                <div className="w-full max-w-md space-y-4">
                    <h2 className="text-xl font-semibold text-center text-foreground">
                        ÈìæÂºèÊìç‰ΩúÊâßË°åÂô®
                    </h2>

                    {state.config && (
                        <p className="text-sm text-center truncate text-muted-foreground">
                            {getTitleFromConfig(state.config, availableActions)}
                        </p>
                    )}

                    <Progress
                        value={state.isExecuting ? undefined : 100}
                        isIndeterminate={state.isExecuting}
                        aria-label={getNotice()}
                        className={`w-full ${state.isExecuting ? 'bg-blue-500' : ''}`}
                        size="sm"
                    />

                    <p className="text-sm text-center text-muted-foreground">
                        {getNotice()}
                    </p>

                    {/* Ê≠•È™§Áä∂ÊÄÅ */}
                    {state.steps.length > 0 && (
                        <div className="space-y-2">
                            {state.steps.map((step, index) => (
                                <div key={index} className="flex items-center gap-3 p-2 border rounded-lg">
                                    {renderStepIcon(step.status)}
                                    <div className="flex-1">
                                        <div className="flex items-center gap-2">
                                            <span className="text-sm font-medium">{step.name}</span>
                                            {renderStepChip(step.status)}
                                        </div>
                                        {step.message && (
                                            <p className="text-xs text-gray-600 mt-1">{step.message}</p>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {/* ÈîôËØØ‰ø°ÊÅØ */}
                    {state.error && (
                        <div className="p-3 bg-red-50 border border-red-200 rounded text-red-700">
                            <p className="text-sm font-medium">ÊâßË°åÂ§±Ë¥•</p>
                            <p className="text-xs mt-1">{state.error}</p>
                        </div>
                    )}

                    {/* ÊâßË°åÊó•Âøó */}
                    {state.logs.length > 0 && (
                        <div className="space-y-2">
                            <p className="text-sm text-center text-muted-foreground">ÊâßË°åÊó•Âøó</p>
                            <div className="h-32 overflow-y-auto bg-gray-50 rounded border p-2 font-mono text-xs">
                                {state.logs.map((log, index) => (
                                    <div key={index} className="mb-1">
                                        {log}
                                    </div>
                                ))}
                                <div ref={logsEndRef} />
                            </div>
                        </div>
                    )}

                    {/* Ëá™Âä®ÂÖ≥Èó≠ËÆæÁΩÆ */}
                    <div className="px-3 py-2 space-y-3 rounded-lg bg-gray-50">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Tooltip
                                    content="ÊâßË°åÂÆåÊàêÂêéËá™Âä®ÂÖ≥Èó≠Á™óÂè£"
                                    placement="top"
                                    className="max-w-xs">
                                    <Switch
                                        isSelected={autoClose}
                                        onChange={handleAutoCloseChange}
                                        size="sm"
                                        className="data-[state=checked]:bg-primary-600 cursor-help">
                                        <span className="text-sm text-gray-700">Ëá™Âä®ÂÖ≥Èó≠</span>
                                    </Switch>
                                </Tooltip>
                                {autoClose && (
                                    <div className="flex items-center gap-1 ml-2">
                                        <NumberInput
                                            hideStepper
                                            size="sm"
                                            variant="underlined"
                                            min="1"
                                            max="10"
                                            value={Math.floor(autoCloseDelay / 60)}
                                            onChange={(e) => handleDelayChange(e)}
                                            className="w-14"
                                        />
                                        <span className="text-xs text-gray-500">min</span>
                                    </div>
                                )}
                            </div>
                            {autoClose && countdown > 0 && (
                                <div className="flex gap-1.5 items-center">
                                    <div className="w-1.5 h-1.5 bg-orange-500 rounded-full animate-pulse" />
                                    <span className="text-xs font-medium text-orange-700">
                                        {countdown}ÁßíÂêéËá™Âä®ÂÖ≥Èó≠
                                    </span>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Êìç‰ΩúÊåâÈíÆ - Âè™Âú®ÈîôËØØÊó∂ÊòæÁ§∫ÈáçËØïÔºåÂÖ∂‰ªñÊó∂ÂÄôÈöêËóè */}
                    {state.error && (
                        <Button
                            color="primary"
                            variant="flat"
                            startContent={<RefreshCw className="w-4 h-4" />}
                            onClick={retryExecution}
                            className="w-full">
                            ÈáçËØï
                        </Button>
                    )}

                    {!state.isExecuting && (
                        <Button
                            color="danger"
                            variant="solid"
                            startContent={<X className="w-4 h-4" />}
                            onClick={handleCloseWindow}
                            className="w-full">
                            ÂÖ≥Èó≠
                        </Button>
                    )}
                </div>

                {/* ËÅîÁ≥ª‰ø°ÊÅØ */}
                <div className="mt-8 text-center">
                    <p className="text-xs text-gray-500">
                        Â¶ÇÊúâÈóÆÈ¢òÔºåËØ∑
                        <a
                            href="https://docs.multipost.app/docs/user-guide/contact-us"
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-500 underline hover:text-blue-600">
                            ËÅîÁ≥ªÊàë‰ª¨
                        </a>
                    </p>
                </div>
            </div>
        </HeroUIProvider>
    );
} 